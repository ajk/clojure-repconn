#!/usr/bin/env perl
#
# repconn - a super simple nREPL client.
#
# Copyright 2016 Antti Koskinen
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use utf8;

use IO::Socket;
use Encode qw(encode decode);
use Time::HiRes qw(time ualarm);

use Data::Dump qw(dd pp);

my $HOST = $ENV{REPCONN_NREPL_HOST} || '127.0.0.1';
my $PORT = $ENV{REPCONN_NREPL_PORT} or die("REPCONN_NREPL_PORT not defined");

my $DEBUG = 0;

##

my $started = time();
sub _log {
    my $now = time - $started;
    warn $now, "\t", join(' ', @_), "\n";
}

sub request {
    my ($payload, $multi) = @_;

    my $sock = IO::Socket::INET->new(
        Proto   => "tcp",
        PeerAddr => $HOST,
        PeerPort  => $PORT,
    ) || die "cannot connect to nrepl server on $HOST:$PORT";

    $sock->autoflush(1);

    print $sock bencode($payload);

    my $response = [];

    my $poll_timeout = 0;

    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };

        while (1) {

            #FIXME better method to detect when server is done sending responses
            ualarm $poll_timeout if $poll_timeout;

            # First time we block until we can start parsing response.
            # After that we wait for $poll_timeout
            read $sock, my $byte, 1;

            # rest shouldn't take more than 30 seconds
            alarm 30;
            my $msg = bdecode($sock, $byte);
            alarm 0;

            # if we are reading stdout, give more time
            $poll_timeout = (ref $msg eq 'HASH' && defined $msg->{out}) ? 0 : 10000; #microseconds

            push @$response, $msg;

            # stop here unless we expect multipart response
            last unless $multi;
        }
    };
    if ($@) {
        die $@ unless $@ eq "alarm\n";   # propagate unexpected errors
    }

    $sock->shutdown(2);

    close $sock;

    return $response;
}


# Simplified version, we only need to encode hashes
sub bencode {
    my ($in) = @_;

    my $out = '';
    foreach (sort keys %$in) {
        $out .= length($_)        . ':' . $_;
        $out .= length($in->{$_}) . ':' . $in->{$_};
    }
    return 'd' . $out . 'e';
}


sub bdecode {
    my ($stream, $byte) = @_;

    # skip reading here if we have peeked the next byte
    unless (defined $byte) {
        read $stream, $byte, 1;
    }

    if ($byte eq 'd') { # HASH
        my $chunk = {};
        while (1) {
            read $stream, $byte, 1;
            last if $byte eq 'e';

            my $key        = bdecode($stream, $byte);
            $chunk->{$key} = bdecode($stream);
        }
        return $chunk;
    }
    elsif ($byte eq 'l') { # ARRAY
        my $chunk = [];
        while (1) {
            read $stream, $byte, 1;
            last if $byte eq 'e';

            push @$chunk, bdecode($stream, $byte);
        }
        return $chunk;
    }
    elsif ($byte eq 'i') { # INTEGER
        my $chunk = '';
        while (1) {
            read $stream, $byte, 1;
            last if $byte eq 'e';

            $chunk .= $byte
        }
        return int $chunk;
    }
    elsif ($byte =~ /[0-9]/) { # STRING
        my $rsize = '';
        while ($byte ne ':') {
            $rsize .= $byte;
            read $stream, $byte, 1;
        }
        my $str = '';
        while ($rsize > 0) {
            my $len = read( $stream, my $chunk, $rsize );
            $str   .= $chunk;
            $rsize -= $len;
        }
        return $str;
    }
}


sub read_code {

    my $input = shift @ARGV;

    my $fh;
    if ($input && -f $input) {
        # input from file
        open $fh, '<', $input or die "failed to open $input: $!";
    }
    elsif ( ! -t STDIN) {
        # input from pipe
        $fh = *STDIN;
    }
    elsif ($input) {
        # input from first argument
        open $fh, '<', \$input;
    }

    return unless $fh;

    my (@sexp, $chunk, $depth, $byte, $prev, $in_string);
    while (read $fh, $byte, 1) {

        if ($byte eq '"') {
            $in_string = ! $in_string unless $prev && $prev eq "\\";
            $chunk .= $byte;
        }
        elsif ($byte eq ';' && ! $in_string) {
            while (1) {
                read($fh, $byte, 1);
                last if $byte eq "\n";
            }
        }
        elsif ($byte eq '(' && ! $in_string) {
            $depth++;
            $chunk .= $byte;
        }
        elsif ($byte eq ')' && ! $in_string) {
            $depth--;
            $chunk .= $byte;
        }
        elsif ($depth) {
            $chunk .= $byte;
        }

        if ($chunk && ! $depth) {
            push @sexp, $chunk;
            $chunk = '';
        }
        $prev = $byte;
    }

    return @sexp;
}

##

sub nrepl_clone {
    my $res = request({op => 'clone'});
    $res->[0]->{'new-session'};
}

sub nrepl_close {
    my ($sess) = @_;
    request({op => 'close', session => $sess});
}

sub nrepl_input {
    my ($sess, $input) = @_;
    request({op => 'stdin', session => $sess, stdin => $input});
}

sub nrepl_eval {
    my ($sess, $code, $multi) = @_;

    my $res = request({op => 'eval', session => $sess, code => encode('UTF-8', $code)}, $multi);

    foreach my $r (@$res) {
        print $r->{out} if defined $r->{out};

        #TODO better formatting, fix socket exceptions
        if (defined $r->{ex} && $r->{ex} !~ /SocketException/) {
            warn pp(nrepl_trace($sess)), "\n";
            die $r->{ex}, "\n";
        }
    }
}

sub nrepl_trace {
    my ($sess) = @_;
    request({op => 'stacktrace', session => $sess});
}

sub nrepl_sigint {
    my ($sess) = @_;
    request({op => 'interrupt', session => $sess});
    nrepl_close($sess);
    die "\n";
}

##

sub run {

    my @sexp = read_code();

    return unless @sexp;

    $DEBUG and _log('parsed', scalar @sexp, 's-expressions');

    # Start fresh repl session

    my $sess = nrepl_clone();

    # Trap ctrl-c
    # Try to interrupt evaluation before exiting

    $SIG{INT} = sub {
        nrepl_sigint($sess);
    };

    $DEBUG and _log('connected to nREPL server, session id', $sess);

    # Read STDIN

    unless (-t STDIN) {
        my @input = <STDIN>;
        nrepl_input($sess, join('', @input));
        $DEBUG and _log('got', scalar @input, 'lines from STDIN' );
    }

    # Inject helper seq for stdin
    nrepl_eval($sess, '(import java.io.BufferedReader)(def <stdin> (line-seq (java.io.BufferedReader. *in*)))');

    # Setup argument list

    my @out = map { s/(?<!\\)"/\\"/; decode('UTF-8', $_) } @ARGV;
    my $argv_def = '(def argv ['. join(' ', map { qq("$_") } @out) .'])';

    nrepl_eval($sess, $argv_def);

    $DEBUG and _log('setup done');

    # Evaluate s-expressions

    foreach (@sexp) {
        $DEBUG and _log('evaluating:');
        $DEBUG and warn $_, "\n";
        nrepl_eval($sess, $_, 1);
    }

    # Close and clean up

    nrepl_close($sess);

    $DEBUG and _log('finished');
}

run();

1;
