#!/usr/bin/env perl
#
# repconn - a super simple nREPL client.
#
# Copyright 2016 Antti Koskinen
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use utf8;

use Fcntl;
use POSIX;
use IO::Socket;
use Encode qw(encode decode);
use Time::HiRes qw(time);

use Data::Dumper;

my $PORT = $ENV{REPCONN_NREPL_PORT} or die("REPCONN_NREPL_PORT not defined");

my $DEBUG = $ENV{REPCONN_DEBUG};

# see if we need to read stdin
my $TTY = -t STDIN;

##

my $STARTED = time();

sub _log {
    my $now = time - $STARTED;
    warn $now, "\t", join(' ', @_), "\n";
}


sub request {
    my ($payload, $expected) = @_;

    $expected ||= 1;

    my $sock = IO::Socket::INET->new(
        Proto   => "tcp",
        PeerAddr => 'localhost',
        PeerPort  => $PORT,
    ) || die "cannot connect to nrepl server on port $PORT";

    $sock->autoflush(1);

    ##

    print $sock bencode($payload);

    ##

    my $response = [];

    my $poll_timeout = 0;

    eval {
        local $SIG{ALRM} = sub { die "alarm\n" };

        while (1) {

            # First time we block until we can start parsing response.
            # After that we wait for $poll_timeout
            alarm $poll_timeout if $poll_timeout;

            read $sock, my $byte, 1;

            # rest shouldn't take more than 30 seconds
            alarm 30;
            my $msg = bdecode($sock, $byte);
            alarm 0;

            $DEBUG and _log(Dumper $msg);

            $poll_timeout = 1;

            push @$response, $msg;

            # exception, bail out
            last if defined $msg->{ex};

            # stop here unless we expect multipart response
            last unless --$expected;
        }
    };
    if ($@) {
        die $@ unless $@ eq "alarm\n"; # propagate unexpected errors
    }

    $sock->shutdown(2);

    close $sock;

    return $response;
}


# Simplified bencode, we only need to encode hashes
sub bencode {
    my ($in) = @_;

    my $out = '';
    foreach my $k (sort keys %$in) {
        my $v = $in->{$k};
        $out .= length($k) . ':' . $k;
        $out .= length($v) . ':' . $v;
    }
    return 'd' . $out . 'e';
}


sub bdecode {
    my ($stream, $byte) = @_;

    # skip reading here if we have peeked the next byte
    unless (defined $byte) {
        read $stream, $byte, 1;
    }

    if ($byte eq 'd') { # HASH
        my $chunk = {};
        while (1) {
            read $stream, $byte, 1;
            last if $byte eq 'e';

            my $key        = bdecode($stream, $byte);
            $chunk->{$key} = bdecode($stream);
        }
        return $chunk;
    }
    elsif ($byte eq 'l') { # ARRAY
        my $chunk = [];
        while (1) {
            read $stream, $byte, 1;
            last if $byte eq 'e';

            push @$chunk, bdecode($stream, $byte);
        }
        return $chunk;
    }
    elsif ($byte eq 'i') { # INTEGER
        my $chunk = '';
        while (1) {
            read $stream, $byte, 1;
            last if $byte eq 'e';

            $chunk .= $byte
        }
        return int $chunk;
    }
    elsif ($byte =~ /[0-9]/) { # STRING
        my $rsize = '';
        while ($byte ne ':') {
            $rsize .= $byte;
            read $stream, $byte, 1;
        }
        my $str = '';
        while ($rsize > 0) {
            my $len = read( $stream, my $chunk, $rsize );
            $str   .= $chunk;
            $rsize -= $len;
        }
        return $str;
    }
}


sub read_code {

    my $input = shift @ARGV;

    my $fh;
    if ($input && -f $input) {
        # input from file
        open $fh, '<', $input or die "failed to open $input: $!";
    }
    elsif ($input && $input =~ /^\s*\(.+\)\s*$/) {
        # input from first argument
        open $fh, '<', \$input;
    }
    elsif ( ! $TTY) {
        # input from pipe
        $fh = *STDIN;

        # if we read code from stdin, we don't have anything coming in from user
        $TTY = 1;
    }

    return unless $fh;

    my (@sexp, $chunk, $depth, $byte, $prev1, $prev2, $in_string);
    while (read $fh, $byte, 1) {

        if ($byte eq '"') {
            $in_string = ! $in_string unless $prev1 && $prev1 eq "\\";
            $chunk .= $byte;
        }
        elsif ($byte eq ';' && ! $in_string) {
            while (1) {
                read($fh, $byte, 1);
                last if $byte eq "\n";
            }
        }
        elsif ($byte eq '(' && ! $in_string) {
            $depth++;

            if (defined $prev2 && $prev2 eq '#' && $prev1 eq '_') {
                $chunk .= $prev2 . $prev1;
            }
            $chunk .= $byte;
        }
        elsif ($byte eq ')' && ! $in_string) {
            $depth--;
            $chunk .= $byte;
        }
        elsif ($depth) {
            $chunk .= $byte;
        }

        if ($chunk && ! $depth) {
            push @sexp, $chunk;
            $chunk = '';
        }
        $prev2 = $prev1;
        $prev1 = $byte;
    }

    return @sexp;
}

##

sub setup_fifos {
    my ($in_fifo, $out_fifo, $err_fifo) = @_;

    foreach ($out_fifo, $in_fifo, $err_fifo) {
        unless (-p $_) { # not a pipe
            if (-e _) {
                # but a something else
                die "won't overwrite $_\n";
            } else {
                POSIX::mkfifo($_, 0666) || die "can't mknod $_: $!";
            }
        }
    }

    my $in_pid = fork();
    die "failed to fork" unless defined $in_pid;

    unless ($in_pid) {
        unless ( $TTY ) {
            sysopen(my $fh, $in_fifo, O_WRONLY) || die "can't write $in_fifo: $!";
            while (<STDIN>) {
                print $fh $_;
            }
            close $fh;
        }
        exit(0);
    }

    my $out_pid = fork();
    die "failed to fork" unless defined $out_pid;

    unless ($out_pid) {
        sysopen(my $fh, $out_fifo, O_RDONLY) || die "can't read $out_fifo: $!";
        while (<$fh>) {
            last if /^\\cD\s*$/; # look for EOF
            print $_;
        }
        close $fh;
        exit(0);
    }

    my $err_pid = fork();
    die "failed to fork" unless defined $err_pid;

    unless ($err_pid) {
        sysopen(my $fh, $err_fifo, O_RDONLY) || die "can't read $err_fifo: $!";
        while (<$fh>) {
            last if /^\\cD\s*$/; # look for EOF
            chomp;
            warn $_, "\n";
        }
        close $fh;
        exit(0);
    }

    return ($in_pid, $out_pid, $err_pid);
}

##

sub nrepl_clone {
    my $res = request({op => 'clone'});
    $res->[0]->{'new-session'} or die "failed to start new nREPL session";
}

sub nrepl_eval {
    my ($sess, $code, $multi) = @_;

    my $res = request({op => 'eval', session => $sess, code => encode('UTF-8', $code)}, $multi);

    foreach my $r (@$res) {
        if (defined $r->{ex}) {
            my $tr = nrepl_trace($sess);
            warn $tr->[0]->{class} . ' ' . $tr->[0]->{message} . "\n";
        }
    }
}

sub nrepl_trace {
    my ($sess) = @_;
    request({op => 'stacktrace', session => $sess});
}

sub nrepl_sigint {
    my ($sess) = @_;
    request({op => 'interrupt', session => $sess});
    nrepl_close($sess);
}

sub nrepl_close {
    my ($sess) = @_;
    request({op => 'close', session => $sess});
}

##

sub run {

    my @sexp = read_code();

    return unless @sexp; # nothing to do

    $DEBUG and _log('parsed', scalar @sexp, 's-expressions');

    # Setup STDIN and STDOUT

    my $in_fifo  = '/tmp/repconn-' . $STARTED . '-' . $$ . '-in';
    my $out_fifo = '/tmp/repconn-' . $STARTED . '-' . $$ . '-out';
    my $err_fifo = '/tmp/repconn-' . $STARTED . '-' . $$ . '-err';

    my ($in_pid, $out_pid, $err_pid) = setup_fifos($in_fifo, $out_fifo, $err_fifo);

    close STDIN;
    close STDOUT;

    # Start fresh repl session

    my $sess = nrepl_clone();

    $DEBUG and _log('connected to nREPL server, session id', $sess);

    # Trap ctrl-c
    # Try to interrupt evaluation before exiting

    $SIG{INT} = sub {

        nrepl_sigint($sess);

        kill 'KILL', $in_pid unless $TTY;
        kill 'KILL', $out_pid;

        unlink($in_fifo, $out_fifo, $err_fifo);

        die "\n";
    };

    # Evaluate s-expressions

    my $ns = shift @sexp;
    unless ($ns =~ /^\(\s*ns /) {
        unshift @sexp, $ns;
        $ns = "(ns user)";
    }

    # Pass our named pipes and argv to nREPL
    # if $TTY == 1 we don't bind *in*
    #
    unshift @sexp, "(binding [*in* repconn-stdin]" unless $TTY;
    unshift @sexp, "(binding [*out* repconn-stdout]";
    unshift @sexp, "(binding [*err* repconn-stderr]";
    push    @sexp, '(.write *err* "\\\\cD\n")';
    push    @sexp, '(println "\\\\cD")';
    push    @sexp, ")";
    push    @sexp, ")";
    push    @sexp, ")" unless $TTY;

    @sexp = ( join('', @sexp) );

    unshift @sexp, "(def repconn-stderr (clojure.java.io/writer \"$err_fifo\"))";
    unshift @sexp, "(def repconn-stdout (clojure.java.io/writer \"$out_fifo\"))";
    unshift @sexp, "(def repconn-stdin  (clojure.java.io/reader \"$in_fifo\"))" unless $TTY;
    unshift @sexp, "(require 'clojure.java.io)";

    # Setup argument list

    my @out = map { s/(?<!\\)"/\\"/; decode('UTF-8', $_) } @ARGV;
    unshift @sexp, '(def argv ['. join(' ', map { qq("$_") } @out) .'])';

    push @sexp, "(.close repconn-stderr)";
    push @sexp, "(.close repconn-stdout)";
    push @sexp, "(.close repconn-stdin)" unless $TTY;

    unshift @sexp, $ns;

    $DEBUG and _log('setup done');

    # Execute!

    foreach (@sexp) {
        $DEBUG and warn $_, "\n";
        nrepl_eval($sess, $_, 3);
    }

    waitpid($in_pid, 0);
    waitpid($out_pid, 0);
    waitpid($err_pid, 0);

    unlink($in_fifo, $out_fifo, $err_fifo);

    nrepl_close($sess);

    $DEBUG and _log('finished');
}

run();

1;
